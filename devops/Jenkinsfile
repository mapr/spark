@Library("jenkins-shared-library@newJFversion")_

env.MAVEN_CENTRAL="${MAVEN_CENTRAL_COMMON}"
env.MAPR_CENTRAL="${MAPR_CENTRAL_COMMON}"
env.MAPR_RELEASES_REPO="${MAPR_RELEASES_REPO_COMMON}"
env.MAPR_SNAPSHOTS_REPO="${MAPR_SNAPSHOTS_REPO_COMMON}"
env.MAPR_MAVEN_REPO="${MAPR_SNAPSHOTS_REPO_COMMON}"

ARTIFACTORY_SERVER=''
YAML_CONFIG=''
env.REPOSITORY_NAME=''
env.GIT_REPO_URL=''
env.GIT_SHORT_COMMIT_SHA=''
env.CURRENT_BUILD_TAG=''
env.BUILD_BY_TAG=false

env.ARTIFACTORY_PATH=''
env.ID=''
env.PROJECT=''

env.DOCKER_REGISTRY="${DOCKER_REGISTRY}"

pipeline {
  agent none
  triggers {
    pollSCM 'H/5 * * * *'
  }
  options {
    skipDefaultCheckout()
    disableConcurrentBuilds()
    timestamps()
  }
  parameters {
    choice(name: 'BUILD_TYPE', choices: ['Dev','EBF','Release'], description: 'default - Dev. EBF and Release args you can use only in release branches.')
    string(name: 'BUILD_ENV_VARS', defaultValue: '', description: 'Variables you can pass to build script. Command will be: "env {THIS VARS} path/to/build.sh".')
    booleanParam(name: 'DO_DEPLOY', defaultValue: true, description: 'Uncheck and Jenkins will skip ./build/mvn deploy')
  }
  stages {
    stage("Setup settings and variables") {
      agent {label "redhat8"}
      steps {
        script {
          ARTIFACTORY_SERVER = Artifactory.server 'artifactory.devops.lab'
          YAML_CONFIG = initVariablesWithYAMLConfig()
        }
      }
    }

    stage("Build & Sign & Upload to Artifactory") {
      agent none
      steps {
        script {
          buildInParallel=[:]
          YAML_CONFIG.build.each {
            buildInParallel["Build ${it.name}"] = { ->

              node (it.hostmachine_jenkins_label) {
                checkout scm
                build(it)
                if(it.rpmSign == true)
                  signing.rpmSign("dist")
                getVersionAndUploadToArtifactory()
              }

            }
          }
          parallel buildInParallel
        }
      }
    }

    stage ("Whitesource Scan") {
      agent {label "redhat8"}
      when {
        equals (actual: YAML_CONFIG.whitesourceScan, expected: true)
      }
      steps {
        script {
          checkout scm
          ws.dockerScan()
        /*Get token of product. We have to communicate with WS API only using 64-digits project's token.
          We are sending request to API and get ALL "project+token" pairs. Then parse this information and find token for current project*/
          productToken = ws.getWSProductToken()

          //Get reports (Excel and json) from WS site and save these reports to files. Once for each format
          ws.getWSReports(productToken)

          //Move latest reports to the "old" folder in Artifactory
          ws.moveOldWsReports(ARTIFACTORY_SERVER)

          //Upload reports (Excel and json) to the Artifactory (to the latest folder)
          ws.uploadToArtifactory(ARTIFACTORY_SERVER)
        }
      }
    }

  }
  post {
    failure {
      script {
        postActions.failure()
      }
    }
    fixed {
      script {
        postActions.fixed()
      }
    }
    aborted {
      script {
        postActions.aborted()
      }
    }
    success {
      script {
        postActions.success()
      }
    }
    always {
      script {
        postActions.always()
      }
    }
  }
}

def build(yamlCurrentBuildItem) {
  def image = yamlCurrentBuildItem.image
  def imageContext = yamlCurrentBuildItem.imageContext

  if (image) {
    image = image.replace("_DOCKER_REGISTRY_", DOCKER_REGISTRY)
  }

  if (imageContext) {
    if (image) {
      error "You can not specify 'image' and 'imageContext' options in build-config.yaml"
    }
    def imageTagScript = yamlCurrentBuildItem.imageTagScript
    image = sh script: imageTagScript, returnStdout: true
    image = image.trim()
    def imageCheckStatus = sh script: "docker inspect -f . '${image}'", returnStatus: true
    if (imageCheckStatus != 0) {
      imageCheckStatus = sh script: "docker pull '${image}'", returnStatus: true
    }
    if (imageCheckStatus != 0) {
      sh """
        docker build \
          --build-arg DOCKER_REGISTRY='${DOCKER_REGISTRY}' \
          -t '${image}' \
          '${imageContext}'
        docker push '${image}'
      """
    }
  }

  def buildCommand = yamlCurrentBuildItem.basicBuildCommands.replace("_BUILD_ENV_VARS_","TIMESTAMP=${ID} DO_DEPLOY=${params.DO_DEPLOY} ${params.BUILD_ENV_VARS}")

  configFileProvider([configFile(fileId: 'maven_settings', variable: 'mvn_settings')]) {
    sh "cat ${env.mvn_settings} > settings.xml"
  }
  docker.image(image).inside (
  "-e MAPR_MIRROR=${MAPR_MIRROR} \
  -e MAPR_CENTRAL=${MAPR_CENTRAL} \
  -e MAVEN_CENTRAL=${MAVEN_CENTRAL} \
  -e MAPR_MAVEN_REPO=${MAPR_MAVEN_REPO} \
  -e BUILD_NUMBER=${ID}.${BUILD_NUMBER} \
  -e MAPR_RELEASES_REPO=${MAPR_RELEASES_REPO} \
  -e MAPR_SNAPSHOTS_REPO=${MAPR_SNAPSHOTS_REPO} \
  -v /root/.m2:/root/.m2:rw \
  -v /root/yum-proxy.conf:/etc/yum.conf:ro \
  -v /etc/hosts:/etc/hosts:ro \
  -v /root/apt-proxy.conf:/etc/apt/apt.conf.d/proxy.conf:ro \
  -v /root/.gradle/gradle.properties:/root/.gradle/gradle.properties:ro \
  -v /etc/profile.d/proxy.sh:/etc/profile.d/proxy.sh:ro \
  -e ANT_OPTS=\"-Dhttp.proxyHost=${HPE_PROXY_HOST} -Dhttp.proxyPort=${HPE_PROXY_PORT} -Dhttps.proxyHost=${HPE_PROXY_HOST} -Dhttps.proxyPort=${HPE_PROXY_PORT} -Dhttp.nonProxyHosts='${HPE_PROXY_EXCEPTIONS}'\" \
  -e MAVEN_OPTS=\"-Dhttp.proxyHost=${HPE_PROXY_HOST} -Dhttp.proxyPort=${HPE_PROXY_PORT} -Dhttps.proxyHost=${HPE_PROXY_HOST} -Dhttps.proxyPort=${HPE_PROXY_PORT} -Dhttp.nonProxyHosts='${HPE_PROXY_EXCEPTIONS}'\" \
  -v /etc/localtime:/etc/localtime:ro \
  -v /root/.ssh:/root/.ssh:rw \
  -v ${WORKSPACE}/settings.xml:/root/.m2/settings.xml:ro") {
    sh """
      cat /etc/*-release > os_release_version.txt; \
      ${buildCommand}
    """
  }
}

def getVersionAndUploadToArtifactory() {
  def osVersionContainerRaw = sh script: 'cat os_release_version.txt', returnStdout:true
  artifactory.uploadToArtifactoryWithOSVersions(ARTIFACTORY_SERVER, osVersionContainerRaw)
}
